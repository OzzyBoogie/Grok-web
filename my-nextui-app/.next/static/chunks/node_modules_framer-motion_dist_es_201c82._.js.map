{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs"],"sourcesContent":["import { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n\nexport { useIsomorphicLayoutEffect };\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,4BAA4B,qKAAA,CAAA,YAAS,GAAG,0HAAA,CAAA,kBAAe,GAAG,0HAAA,CAAA,YAAS"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs"],"sourcesContent":["import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    const isMounted = useRef(false);\n    useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n"],"names":[],"mappings":";;;;;;;;AAGA,SAAS;IACL,MAAM,YAAY,CAAA,GAAA,0HAAA,CAAA,SAAM,AAAD,EAAE;IACzB,CAAA,GAAA,mLAAA,CAAA,4BAAyB,AAAD,EAAE;QACtB,UAAU,OAAO,GAAG;QACpB,OAAO;YACH,UAAU,OAAO,GAAG;QACxB;IACJ,GAAG,EAAE;IACL,OAAO;AACX"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/utils/use-force-update.mjs"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nfunction useForceUpdate() {\n    const isMounted = useIsMounted();\n    const [forcedRenderCount, setForcedRenderCount] = useState(0);\n    const forceRender = useCallback(() => {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    const deferredForceRender = useCallback(() => frame.postRender(forceRender), [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,SAAS;IACL,MAAM,YAAY,CAAA,GAAA,4KAAA,CAAA,eAAY,AAAD;IAC7B,MAAM,CAAC,mBAAmB,qBAAqB,GAAG,CAAA,GAAA,0HAAA,CAAA,WAAQ,AAAD,EAAE;IAC3D,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,cAAW,AAAD,EAAE;QAC5B,UAAU,OAAO,IAAI,qBAAqB,oBAAoB;IAClE,GAAG;QAAC;KAAkB;IACtB;;;KAGC,GACD,MAAM,sBAAsB,CAAA,GAAA,0HAAA,CAAA,cAAW,AAAD,EAAE,IAAM,iKAAA,CAAA,QAAK,CAAC,UAAU,CAAC,cAAc;QAAC;KAAY;IAC1F,OAAO;QAAC;QAAqB;KAAkB;AACnD"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/utils/use-constant.mjs"],"sourcesContent":["import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n"],"names":[],"mappings":";;;;;;AAEA;;;;;;CAMC,GACD,SAAS,YAAY,IAAI;IACrB,MAAM,MAAM,CAAA,GAAA,0HAAA,CAAA,SAAM,AAAD,EAAE;IACnB,IAAI,IAAI,OAAO,KAAK,MAAM;QACtB,IAAI,OAAO,GAAG;IAClB;IACA,OAAO,IAAI,OAAO;AACtB"}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs"],"sourcesContent":["import { useEffect } from 'react';\n\nfunction useUnmountEffect(callback) {\n    return useEffect(() => () => callback(), []);\n}\n\nexport { useUnmountEffect };\n"],"names":[],"mappings":";;;;;;AAEA,SAAS,iBAAiB,QAAQ;IAC9B,OAAO,CAAA,GAAA,0HAAA,CAAA,YAAS,AAAD,EAAE,IAAM,IAAM,YAAY,EAAE;AAC/C"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 203, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/context/LazyContext.mjs"],"sourcesContent":["import { createContext } from 'react';\n\nconst LazyContext = createContext({ strict: false });\n\nexport { LazyContext };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,gBAAa,AAAD,EAAE;IAAE,QAAQ;AAAM"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs"],"sourcesContent":["import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef();\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    useInsertionEffect(() => {\n        visualElement && visualElement.update(props, presenceContext);\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const wantsHandoff = useRef(Boolean(props[optimizedAppearDataAttribute] &&\n        !window.HandoffComplete));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        microtask.postRender(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        visualElement.updateFeatures();\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            wantsHandoff.current = false;\n            // This ensures all future calls to animateChanges() will run in useEffect\n            window.HandoffComplete = true;\n        }\n    });\n    return visualElement;\n}\n\nexport { useVisualElement };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AASA,SAAS,iBAAiB,SAAS,EAAE,WAAW,EAAE,KAAK,EAAE,mBAAmB;IACxE,MAAM,EAAE,eAAe,MAAM,EAAE,GAAG,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,gLAAA,CAAA,gBAAa;IAC1D,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,qKAAA,CAAA,cAAW;IAC1C,MAAM,kBAAkB,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,yKAAA,CAAA,kBAAe;IAClD,MAAM,sBAAsB,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,6KAAA,CAAA,sBAAmB,EAAE,aAAa;IACzE,MAAM,mBAAmB,CAAA,GAAA,0HAAA,CAAA,SAAM,AAAD;IAC9B;;KAEC,GACD,sBAAsB,uBAAuB,YAAY,QAAQ;IACjE,IAAI,CAAC,iBAAiB,OAAO,IAAI,qBAAqB;QAClD,iBAAiB,OAAO,GAAG,oBAAoB,WAAW;YACtD;YACA;YACA;YACA;YACA,uBAAuB,kBACjB,gBAAgB,OAAO,KAAK,QAC5B;YACN;QACJ;IACJ;IACA,MAAM,gBAAgB,iBAAiB,OAAO;IAC9C,CAAA,GAAA,0HAAA,CAAA,qBAAkB,AAAD,EAAE;QACf,iBAAiB,cAAc,MAAM,CAAC,OAAO;IACjD;IACA;;;KAGC,GACD,MAAM,eAAe,CAAA,GAAA,0HAAA,CAAA,SAAM,AAAD,EAAE,QAAQ,KAAK,CAAC,6LAAA,CAAA,+BAA4B,CAAC,IACnE,CAAC,OAAO,eAAe;IAC3B,CAAA,GAAA,mLAAA,CAAA,4BAAyB,AAAD,EAAE;QACtB,IAAI,CAAC,eACD;QACJ,qKAAA,CAAA,YAAS,CAAC,UAAU,CAAC,cAAc,MAAM;QACzC;;;;;;;;;SASC,GACD,IAAI,aAAa,OAAO,IAAI,cAAc,cAAc,EAAE;YACtD,cAAc,cAAc,CAAC,cAAc;QAC/C;IACJ;IACA,CAAA,GAAA,0HAAA,CAAA,YAAS,AAAD,EAAE;QACN,IAAI,CAAC,eACD;QACJ,cAAc,cAAc;QAC5B,IAAI,CAAC,aAAa,OAAO,IAAI,cAAc,cAAc,EAAE;YACvD,cAAc,cAAc,CAAC,cAAc;QAC/C;QACA,IAAI,aAAa,OAAO,EAAE;YACtB,aAAa,OAAO,GAAG;YACvB,0EAA0E;YAC1E,OAAO,eAAe,GAAG;QAC7B;IACJ;IACA,OAAO;AACX"}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/motion/index.mjs"],"sourcesContent":["import { jsxs, jsx } from 'react/jsx-runtime';\nimport { forwardRef, useContext } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { SwitchLayoutGroupContext } from '../context/SwitchLayoutGroupContext.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */\n            const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n            const isStrict = useContext(LazyContext).strict;\n            if (context.visualElement) {\n                MeasureLayout = context.visualElement.loadFeatures(\n                // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n                configAndProps, isStrict, preloadedFeatures, initialLayoutGroupConfig);\n            }\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    const ForwardRefComponent = forwardRef(MotionComponent);\n    ForwardRefComponent[motionComponentSymbol] = Component;\n    return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\n\nexport { createMotionComponent };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;;;CAQC,GACD,SAAS,sBAAsB,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,SAAS,EAAE,cAAc,EAAE,SAAS,EAAG;IAC5G,qBAAqB,CAAA,GAAA,qLAAA,CAAA,eAAY,AAAD,EAAE;IAClC,SAAS,gBAAgB,KAAK,EAAE,WAAW;QACvC;;;SAGC,GACD,IAAI;QACJ,MAAM,iBAAiB;YACnB,GAAG,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,6KAAA,CAAA,sBAAmB,CAAC;YAClC,GAAG,KAAK;YACR,UAAU,YAAY;QAC1B;QACA,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,MAAM,UAAU,CAAA,GAAA,iLAAA,CAAA,yBAAsB,AAAD,EAAE;QACvC,MAAM,cAAc,eAAe,OAAO;QAC1C,IAAI,CAAC,YAAY,qKAAA,CAAA,YAAS,EAAE;YACxB;;;;;aAKC,GACD,QAAQ,aAAa,GAAG,CAAA,GAAA,0LAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW,aAAa,gBAAgB;YACjF;;;aAGC,GACD,MAAM,2BAA2B,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,kLAAA,CAAA,2BAAwB;YACpE,MAAM,WAAW,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,qKAAA,CAAA,cAAW,EAAE,MAAM;YAC/C,IAAI,QAAQ,aAAa,EAAE;gBACvB,gBAAgB,QAAQ,aAAa,CAAC,YAAY,CAClD,4FAA4F;gBAC5F,gBAAgB,UAAU,mBAAmB;YACjD;QACJ;QACA;;;SAGC,GACD,OAAQ,CAAA,GAAA,mIAAA,CAAA,OAAI,AAAD,EAAE,gLAAA,CAAA,gBAAa,CAAC,QAAQ,EAAE;YAAE,OAAO;YAAS,UAAU;gBAAC,iBAAiB,QAAQ,aAAa,GAAI,CAAA,GAAA,mIAAA,CAAA,MAAG,AAAD,EAAE,eAAe;oBAAE,eAAe,QAAQ,aAAa;oBAAE,GAAG,cAAc;gBAAC,KAAM;gBAAM,UAAU,WAAW,OAAO,CAAA,GAAA,sLAAA,CAAA,eAAY,AAAD,EAAE,aAAa,QAAQ,aAAa,EAAE,cAAc,aAAa,UAAU,QAAQ,aAAa;aAAE;QAAC;IACnV;IACA,MAAM,sBAAsB,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE;IACvC,mBAAmB,CAAC,wKAAA,CAAA,wBAAqB,CAAC,GAAG;IAC7C,OAAO;AACX;AACA,SAAS,YAAY,EAAE,QAAQ,EAAE;IAC7B,MAAM,gBAAgB,CAAA,GAAA,0HAAA,CAAA,aAAU,AAAD,EAAE,oBAAoB,EAAE;IACvD,OAAO,iBAAiB,aAAa,YAC/B,gBAAgB,MAAM,WACtB;AACV"}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 601, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/html/use-props.mjs"],"sourcesContent":["import { useMemo } from 'react';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n    return useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState, isStatic);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\nexport { copyRawValuesOnly, useHTMLProps };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAMA,SAAS,kBAAkB,MAAM,EAAE,MAAM,EAAE,KAAK;IAC5C,IAAK,MAAM,OAAO,OAAQ;QACtB,IAAI,CAAC,CAAA,GAAA,sLAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,CAAC,IAAI,KAAK,CAAC,CAAA,GAAA,iMAAA,CAAA,sBAAmB,AAAD,EAAE,KAAK,QAAQ;YACjE,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC7B;IACJ;AACJ;AACA,SAAS,uBAAuB,EAAE,iBAAiB,EAAE,EAAE,WAAW,EAAE,QAAQ;IACxE,OAAO,CAAA,GAAA,0HAAA,CAAA,UAAO,AAAD,EAAE;QACX,MAAM,QAAQ,CAAA,GAAA,mMAAA,CAAA,wBAAqB,AAAD;QAClC,CAAA,GAAA,yLAAA,CAAA,kBAAe,AAAD,EAAE,OAAO,aAAa;YAAE,4BAA4B,CAAC;QAAS,GAAG;QAC/E,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,IAAI,EAAE,MAAM,KAAK;IACpD,GAAG;QAAC;KAAY;AACpB;AACA,SAAS,SAAS,KAAK,EAAE,WAAW,EAAE,QAAQ;IAC1C,MAAM,YAAY,MAAM,KAAK,IAAI,CAAC;IAClC,MAAM,QAAQ,CAAC;IACf;;KAEC,GACD,kBAAkB,OAAO,WAAW;IACpC,OAAO,MAAM,CAAC,OAAO,uBAAuB,OAAO,aAAa;IAChE,OAAO;AACX;AACA,SAAS,aAAa,KAAK,EAAE,WAAW,EAAE,QAAQ;IAC9C,2EAA2E;IAC3E,MAAM,YAAY,CAAC;IACnB,MAAM,QAAQ,SAAS,OAAO,aAAa;IAC3C,IAAI,MAAM,IAAI,IAAI,MAAM,YAAY,KAAK,OAAO;QAC5C,8CAA8C;QAC9C,UAAU,SAAS,GAAG;QACtB,yBAAyB;QACzB,MAAM,UAAU,GACZ,MAAM,gBAAgB,GAClB,MAAM,kBAAkB,GACpB;QACZ,+CAA+C;QAC/C,MAAM,WAAW,GACb,MAAM,IAAI,KAAK,OACT,SACA,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,MAAM,MAAM,IAAI,CAAC;IACrD;IACA,IAAI,MAAM,QAAQ,KAAK,aACnB,CAAC,MAAM,KAAK,IAAI,MAAM,UAAU,IAAI,MAAM,QAAQ,GAAG;QACrD,UAAU,QAAQ,GAAG;IACzB;IACA,UAAU,KAAK,GAAG;IAClB,OAAO;AACX"}},
    {"offset": {"line": 662, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs"],"sourcesContent":["import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\nimport { buildSVGPath } from './path.mjs';\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, options, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n"],"names":[],"mappings":";;;;;;;;;;AAIA;;CAEC,GACD,SAAS,cAAc,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC,EAAE,aAAa,CAAC,EACtH,4DAA4D;AAC5D,GAAG,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,iBAAiB;IAC7C,CAAA,GAAA,yLAAA,CAAA,kBAAe,AAAD,EAAE,OAAO,QAAQ,SAAS;IACxC;;;KAGC,GACD,IAAI,UAAU;QACV,IAAI,MAAM,KAAK,CAAC,OAAO,EAAE;YACrB,MAAM,KAAK,CAAC,OAAO,GAAG,MAAM,KAAK,CAAC,OAAO;QAC7C;QACA;IACJ;IACA,MAAM,KAAK,GAAG,MAAM,KAAK;IACzB,MAAM,KAAK,GAAG,CAAC;IACf,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,GAAG;IACrC;;;KAGC,GACD,IAAI,MAAM,SAAS,EAAE;QACjB,IAAI,YACA,MAAM,SAAS,GAAG,MAAM,SAAS;QACrC,OAAO,MAAM,SAAS;IAC1B;IACA,wBAAwB;IACxB,IAAI,cACA,CAAC,YAAY,aAAa,YAAY,aAAa,MAAM,SAAS,GAAG;QACrE,MAAM,eAAe,GAAG,CAAA,GAAA,4LAAA,CAAA,yBAAsB,AAAD,EAAE,YAAY,YAAY,YAAY,UAAU,KAAK,YAAY,YAAY,UAAU;IACxI;IACA,6CAA6C;IAC7C,IAAI,UAAU,WACV,MAAM,CAAC,GAAG;IACd,IAAI,UAAU,WACV,MAAM,CAAC,GAAG;IACd,IAAI,cAAc,WACd,MAAM,KAAK,GAAG;IAClB,yCAAyC;IACzC,IAAI,eAAe,WAAW;QAC1B,CAAA,GAAA,6KAAA,CAAA,eAAY,AAAD,EAAE,OAAO,YAAY,aAAa,YAAY;IAC7D;AACJ"}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs"],"sourcesContent":["import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nexport { createSvgRenderState };\n"],"names":[],"mappings":";;;;;;AAEA,MAAM,uBAAuB,IAAM,CAAC;QAChC,GAAG,CAAA,GAAA,mMAAA,CAAA,wBAAqB,AAAD,GAAG;QAC1B,OAAO,CAAC;IACZ,CAAC"}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/svg/use-props.mjs"],"sourcesContent":["import { useMemo } from 'react';\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nexport { useSVGProps };\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMA,SAAS,YAAY,KAAK,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS;IACzD,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,UAAO,AAAD,EAAE;QACxB,MAAM,QAAQ,CAAA,GAAA,kMAAA,CAAA,uBAAoB,AAAD;QACjC,CAAA,GAAA,uLAAA,CAAA,gBAAa,AAAD,EAAE,OAAO,aAAa;YAAE,4BAA4B;QAAM,GAAG,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,YAAY,MAAM,iBAAiB;QACrH,OAAO;YACH,GAAG,MAAM,KAAK;YACd,OAAO;gBAAE,GAAG,MAAM,KAAK;YAAC;QAC5B;IACJ,GAAG;QAAC;KAAY;IAChB,IAAI,MAAM,KAAK,EAAE;QACb,MAAM,YAAY,CAAC;QACnB,CAAA,GAAA,6KAAA,CAAA,oBAAiB,AAAD,EAAE,WAAW,MAAM,KAAK,EAAE;QAC1C,YAAY,KAAK,GAAG;YAAE,GAAG,SAAS;YAAE,GAAG,YAAY,KAAK;QAAC;IAC7D;IACA,OAAO;AACX"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 877, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/svg/config-motion.mjs"],"sourcesContent":["import { renderSVG } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: (props, instance, { renderState, latestValues }) => {\n            frame.read(() => {\n                try {\n                    renderState.dimensions =\n                        typeof instance.getBBox ===\n                            \"function\"\n                            ? instance.getBBox()\n                            : instance.getBoundingClientRect();\n                }\n                catch (e) {\n                    // Most likely trying to measure an unrendered element under Firefox\n                    renderState.dimensions = {\n                        x: 0,\n                        y: 0,\n                        width: 0,\n                        height: 0,\n                    };\n                }\n            });\n            frame.render(() => {\n                buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);\n                renderSVG(instance, renderState);\n            });\n        },\n    }),\n};\n\nexport { svgMotionConfig };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAQA,MAAM,kBAAkB;IACpB,gBAAgB,CAAA,GAAA,wLAAA,CAAA,qBAAkB,AAAD,EAAE;QAC/B,6BAA6B,mMAAA,CAAA,8BAA2B;QACxD,mBAAmB,kMAAA,CAAA,uBAAoB;QACvC,SAAS,CAAC,OAAO,UAAU,EAAE,WAAW,EAAE,YAAY,EAAE;YACpD,iKAAA,CAAA,QAAK,CAAC,IAAI,CAAC;gBACP,IAAI;oBACA,YAAY,UAAU,GAClB,OAAO,SAAS,OAAO,KACnB,aACE,SAAS,OAAO,KAChB,SAAS,qBAAqB;gBAC5C,EACA,OAAO,GAAG;oBACN,oEAAoE;oBACpE,YAAY,UAAU,GAAG;wBACrB,GAAG;wBACH,GAAG;wBACH,OAAO;wBACP,QAAQ;oBACZ;gBACJ;YACJ;YACA,iKAAA,CAAA,QAAK,CAAC,MAAM,CAAC;gBACT,CAAA,GAAA,uLAAA,CAAA,gBAAa,AAAD,EAAE,aAAa,cAAc;oBAAE,4BAA4B;gBAAM,GAAG,CAAA,GAAA,yLAAA,CAAA,WAAQ,AAAD,EAAE,SAAS,OAAO,GAAG,MAAM,iBAAiB;gBACnI,CAAA,GAAA,+KAAA,CAAA,YAAS,AAAD,EAAE,UAAU;YACxB;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 923, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/html/config-motion.mjs"],"sourcesContent":["import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nexport { htmlMotionConfig };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAM,mBAAmB;IACrB,gBAAgB,CAAA,GAAA,wLAAA,CAAA,qBAAkB,AAAD,EAAE;QAC/B,6BAAA,oMAAA,CAAA,8BAA2B;QAC3B,mBAAmB,mMAAA,CAAA,wBAAqB;IAC5C;AACJ"}},
    {"offset": {"line": 945, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { transformPropOrder } from '../../html/utils/transform.mjs';\nimport { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\",\n]);\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nexport { isNumOrPxType, positionalKeys, positionalValues, removeNonTranslationalTransform };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAIA,MAAM,iBAAiB,IAAI,IAAI;IAC3B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD,MAAM,gBAAgB,CAAC,IAAM,MAAM,iLAAA,CAAA,SAAM,IAAI,MAAM,iLAAA,CAAA,KAAE;AACrD,MAAM,mBAAmB,CAAC,QAAQ,MAAQ,WAAW,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI;AAC5E,MAAM,yBAAyB,CAAC,MAAM,OAAS,CAAC,OAAO,EAAE,SAAS,EAAE;QAChE,IAAI,cAAc,UAAU,CAAC,WACzB,OAAO;QACX,MAAM,WAAW,UAAU,KAAK,CAAC;QACjC,IAAI,UAAU;YACV,OAAO,iBAAiB,QAAQ,CAAC,EAAE,EAAE;QACzC,OACK;YACD,MAAM,SAAS,UAAU,KAAK,CAAC;YAC/B,IAAI,QAAQ;gBACR,OAAO,iBAAiB,MAAM,CAAC,EAAE,EAAE;YACvC,OACK;gBACD,OAAO;YACX;QACJ;IACJ;AACA,MAAM,gBAAgB,IAAI,IAAI;IAAC;IAAK;IAAK;CAAI;AAC7C,MAAM,gCAAgC,mLAAA,CAAA,qBAAkB,CAAC,MAAM,CAAC,CAAC,MAAQ,CAAC,cAAc,GAAG,CAAC;AAC5F,SAAS,gCAAgC,aAAa;IAClD,MAAM,oBAAoB,EAAE;IAC5B,8BAA8B,OAAO,CAAC,CAAC;QACnC,MAAM,QAAQ,cAAc,QAAQ,CAAC;QACrC,IAAI,UAAU,WAAW;YACrB,kBAAkB,IAAI,CAAC;gBAAC;gBAAK,MAAM,GAAG;aAAG;YACzC,MAAM,GAAG,CAAC,IAAI,UAAU,CAAC,WAAW,IAAI;QAC5C;IACJ;IACA,OAAO;AACX;AACA,MAAM,mBAAmB;IACrB,aAAa;IACb,OAAO,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,cAAc,GAAG,EAAE,eAAe,GAAG,EAAE,GAAK,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,WAAW,eAAe,WAAW;IAClH,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,aAAa,GAAG,EAAE,gBAAgB,GAAG,EAAE,GAAK,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,WAAW,cAAc,WAAW;IAClH,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,GAAK,WAAW;IACpC,MAAM,CAAC,OAAO,EAAE,IAAI,EAAE,GAAK,WAAW;IACtC,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAK,WAAW,OAAO,CAAC,EAAE,GAAG,GAAG,EAAE,GAAG;IAC5D,OAAO,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,GAAK,WAAW,QAAQ,CAAC,EAAE,GAAG,GAAG,EAAE,GAAG;IAC7D,YAAY;IACZ,GAAG,uBAAuB,GAAG;IAC7B,GAAG,uBAAuB,GAAG;AACjC;AACA,iCAAiC;AACjC,iBAAiB,UAAU,GAAG,iBAAiB,CAAC;AAChD,iBAAiB,UAAU,GAAG,iBAAiB,CAAC"}},
    {"offset": {"line": 1117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs"],"sourcesContent":["import { number } from '../../../value/types/numbers/index.mjs';\nimport { px, percent, degrees, vw, vh } from '../../../value/types/numbers/units.mjs';\nimport { testValueType } from './test.mjs';\nimport { auto } from './type-auto.mjs';\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\nexport { dimensionValueTypes, findDimensionValueType };\n"],"names":[],"mappings":";;;;;;;;;;;;;AAKA;;CAEC,GACD,MAAM,sBAAsB;IAAC,iLAAA,CAAA,SAAM;IAAE,iLAAA,CAAA,KAAE;IAAE,iLAAA,CAAA,UAAO;IAAE,iLAAA,CAAA,UAAO;IAAE,iLAAA,CAAA,KAAE;IAAE,iLAAA,CAAA,KAAE;IAAE,8LAAA,CAAA,OAAI;CAAC;AACxE;;CAEC,GACD,MAAM,yBAAyB,CAAC,IAAM,oBAAoB,IAAI,CAAC,CAAA,GAAA,sLAAA,CAAA,gBAAa,AAAD,EAAE"}},
    {"offset": {"line": 1162, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1191, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/value/types/color/hsla.mjs"],"sourcesContent":["import { alpha } from '../numbers/index.mjs';\nimport { percent } from '../numbers/units.mjs';\nimport { sanitize } from '../utils.mjs';\nimport { isColorString, splitColor } from './utils.mjs';\n\nconst hsla = {\n    test: isColorString(\"hsl\", \"hue\"),\n    parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nexport { hsla };\n"],"names":[],"mappings":";;;;;;;;;;;;AAKA,MAAM,OAAO;IACT,MAAM,CAAA,GAAA,+KAAA,CAAA,gBAAa,AAAD,EAAE,OAAO;IAC3B,OAAO,CAAA,GAAA,+KAAA,CAAA,aAAU,AAAD,EAAE,OAAO,cAAc;IACvC,WAAW,CAAC,EAAE,GAAG,EAAE,UAAU,EAAE,SAAS,EAAE,OAAO,UAAU,CAAC,EAAE;QAC1D,OAAQ,UACJ,KAAK,KAAK,CAAC,OACX,OACA,iLAAA,CAAA,UAAO,CAAC,SAAS,CAAC,CAAA,GAAA,sKAAA,CAAA,WAAQ,AAAD,EAAE,eAC3B,OACA,iLAAA,CAAA,UAAO,CAAC,SAAS,CAAC,CAAA,GAAA,sKAAA,CAAA,WAAQ,AAAD,EAAE,cAC3B,OACA,CAAA,GAAA,sKAAA,CAAA,WAAQ,AAAD,EAAE,iLAAA,CAAA,QAAK,CAAC,SAAS,CAAC,YACzB;IACR;AACJ"}},
    {"offset": {"line": 1211, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/value/types/color/index.mjs"],"sourcesContent":["import { isString } from '../utils.mjs';\nimport { hex } from './hex.mjs';\nimport { hsla } from './hsla.mjs';\nimport { rgba } from './rgba.mjs';\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\nexport { color };\n"],"names":[],"mappings":";;;;;;;;;;;;AAKA,MAAM,QAAQ;IACV,MAAM,CAAC,IAAM,8KAAA,CAAA,OAAI,CAAC,IAAI,CAAC,MAAM,6KAAA,CAAA,MAAG,CAAC,IAAI,CAAC,MAAM,8KAAA,CAAA,OAAI,CAAC,IAAI,CAAC;IACtD,OAAO,CAAC;QACJ,IAAI,8KAAA,CAAA,OAAI,CAAC,IAAI,CAAC,IAAI;YACd,OAAO,8KAAA,CAAA,OAAI,CAAC,KAAK,CAAC;QACtB,OACK,IAAI,8KAAA,CAAA,OAAI,CAAC,IAAI,CAAC,IAAI;YACnB,OAAO,8KAAA,CAAA,OAAI,CAAC,KAAK,CAAC;QACtB,OACK;YACD,OAAO,6KAAA,CAAA,MAAG,CAAC,KAAK,CAAC;QACrB;IACJ;IACA,WAAW,CAAC;QACR,OAAO,CAAA,GAAA,sKAAA,CAAA,WAAQ,AAAD,EAAE,KACV,IACA,EAAE,cAAc,CAAC,SACb,8KAAA,CAAA,OAAI,CAAC,SAAS,CAAC,KACf,8KAAA,CAAA,OAAI,CAAC,SAAS,CAAC;IAC7B;AACJ"}},
    {"offset": {"line": 1244, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1249, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"sourcesContent":["import { color } from '../color/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = \"\";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\nexport { analyseComplexValue, complex };\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAGA,SAAS,KAAK,CAAC;IACX,IAAI,IAAI;IACR,OAAQ,MAAM,MACV,CAAA,GAAA,sKAAA,CAAA,WAAQ,AAAD,EAAE,MACT,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,sKAAA,CAAA,aAAU,CAAC,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,MAAM,KAAK,CAAC,IAC7E,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,sKAAA,CAAA,aAAU,CAAC,MAAM,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,MAAM,KAAK,CAAC,IACjF;AACZ;AACA,MAAM,eAAe;AACrB,MAAM,cAAc;AACpB,MAAM,YAAY;AAClB,MAAM,qBAAqB;AAC3B,MAAM,cAAc;AACpB,kFAAkF;AAClF,MAAM,eAAe;AACrB,SAAS,oBAAoB,KAAK;IAC9B,MAAM,gBAAgB,MAAM,QAAQ;IACpC,MAAM,SAAS,EAAE;IACjB,MAAM,UAAU;QACZ,OAAO,EAAE;QACT,QAAQ,EAAE;QACV,KAAK,EAAE;IACX;IACA,MAAM,QAAQ,EAAE;IAChB,IAAI,IAAI;IACR,MAAM,YAAY,cAAc,OAAO,CAAC,cAAc,CAAC;QACnD,IAAI,+KAAA,CAAA,QAAK,CAAC,IAAI,CAAC,cAAc;YACzB,QAAQ,KAAK,CAAC,IAAI,CAAC;YACnB,MAAM,IAAI,CAAC;YACX,OAAO,IAAI,CAAC,+KAAA,CAAA,QAAK,CAAC,KAAK,CAAC;QAC5B,OACK,IAAI,YAAY,UAAU,CAAC,qBAAqB;YACjD,QAAQ,GAAG,CAAC,IAAI,CAAC;YACjB,MAAM,IAAI,CAAC;YACX,OAAO,IAAI,CAAC;QAChB,OACK;YACD,QAAQ,MAAM,CAAC,IAAI,CAAC;YACpB,MAAM,IAAI,CAAC;YACX,OAAO,IAAI,CAAC,WAAW;QAC3B;QACA,EAAE;QACF,OAAO;IACX;IACA,MAAM,QAAQ,UAAU,KAAK,CAAC;IAC9B,OAAO;QAAE;QAAQ;QAAO;QAAS;IAAM;AAC3C;AACA,SAAS,kBAAkB,CAAC;IACxB,OAAO,oBAAoB,GAAG,MAAM;AACxC;AACA,SAAS,kBAAkB,MAAM;IAC7B,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,oBAAoB;IAC7C,MAAM,cAAc,MAAM,MAAM;IAChC,OAAO,CAAC;QACJ,IAAI,SAAS;QACb,IAAK,IAAI,IAAI,GAAG,IAAI,aAAa,IAAK;YAClC,UAAU,KAAK,CAAC,EAAE;YAClB,IAAI,CAAC,CAAC,EAAE,KAAK,WAAW;gBACpB,MAAM,OAAO,KAAK,CAAC,EAAE;gBACrB,IAAI,SAAS,cAAc;oBACvB,UAAU,SAAS,CAAC,CAAC,EAAE;gBAC3B,OACK,IAAI,SAAS,aAAa;oBAC3B,UAAU,+KAAA,CAAA,QAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;gBAClC,OACK;oBACD,UAAU,CAAC,CAAC,EAAE;gBAClB;YACJ;QACJ;QACA,OAAO;IACX;AACJ;AACA,MAAM,uBAAuB,CAAC,IAAM,OAAO,MAAM,WAAW,IAAI;AAChE,SAAS,kBAAkB,CAAC;IACxB,MAAM,SAAS,kBAAkB;IACjC,MAAM,cAAc,kBAAkB;IACtC,OAAO,YAAY,OAAO,GAAG,CAAC;AAClC;AACA,MAAM,UAAU;IACZ;IACA,OAAO;IACP;IACA;AACJ"}},
    {"offset": {"line": 1346, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs"],"sourcesContent":["import { complex } from '../../../value/types/complex/index.mjs';\nimport { filter } from '../../../value/types/complex/filter.mjs';\nimport { getDefaultValueType } from './defaults.mjs';\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\nexport { getAnimatableNone };\n"],"names":[],"mappings":";;;;;;;;;;AAIA,SAAS,kBAAkB,GAAG,EAAE,KAAK;IACjC,IAAI,mBAAmB,CAAA,GAAA,0LAAA,CAAA,sBAAmB,AAAD,EAAE;IAC3C,IAAI,qBAAqB,kLAAA,CAAA,SAAM,EAC3B,mBAAmB,iLAAA,CAAA,UAAO;IAC9B,+GAA+G;IAC/G,OAAO,iBAAiB,iBAAiB,GACnC,iBAAiB,iBAAiB,CAAC,SACnC;AACV"}},
    {"offset": {"line": 1380, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1451, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs"],"sourcesContent":["import { noop } from '../utils/noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n"],"names":[],"mappings":";;;;;;AAEA;;;;;;;;;;;;;;;;AAgBA,GACA,iEAAiE;AACjE,MAAM,aAAa,CAAC,GAAG,IAAI,KAAO,CAAC,CAAC,CAAC,MAAM,MAAM,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC,IAAI,IAAI,MAAM,EAAE,IACvG;AACJ,MAAM,uBAAuB;AAC7B,MAAM,2BAA2B;AACjC,SAAS,gBAAgB,CAAC,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,EAAE,GAAG;IACxD,IAAI;IACJ,IAAI;IACJ,IAAI,IAAI;IACR,GAAG;QACC,WAAW,aAAa,CAAC,aAAa,UAAU,IAAI;QACpD,WAAW,WAAW,UAAU,KAAK,OAAO;QAC5C,IAAI,WAAW,KAAK;YAChB,aAAa;QACjB,OACK;YACD,aAAa;QACjB;IACJ,QAAS,KAAK,GAAG,CAAC,YAAY,wBAC1B,EAAE,IAAI,yBAA0B;IACpC,OAAO;AACX;AACA,SAAS,YAAY,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IACnC,qDAAqD;IACrD,IAAI,QAAQ,OAAO,QAAQ,KACvB,OAAO,4JAAA,CAAA,OAAI;IACf,MAAM,WAAW,CAAC,KAAO,gBAAgB,IAAI,GAAG,GAAG,KAAK;IACxD,wDAAwD;IACxD,OAAO,CAAC,IAAM,MAAM,KAAK,MAAM,IAAI,IAAI,WAAW,SAAS,IAAI,KAAK;AACxE"}},
    {"offset": {"line": 1500, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1637, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"sourcesContent":["import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, keyframes } = this.options;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        if (name && motionValue && motionValue.owner) {\n            this.resolver = motionValue.owner.resolveKeyframes(keyframes, onResolved, name, motionValue);\n        }\n        else {\n            this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue);\n        }\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime || this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2009, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"names":[],"mappings":";;;;;;;;AAGA,MAAM,iBAAiB;IACnB,MAAM;IACN,KAAK;AACT;AACA,MAAM,sBAAsB,4KAAA,CAAA,UAAO;IAC/B,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,gBAAgB;QACZ,IAAI,CAAC,OAAO;QACZ,MAAM,EAAE,WAAW,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QAC5C,MAAM,EAAE,IAAI,EAAE,QAAQ,UAAU,EAAE,SAAS,MAAM,EAAE,IAAI,EAAE,GAAG;QAC5D,MAAM,UAAU;YACZ,MAAM,OAAO,KAAK,OAAO,GAAG;YAC5B;YACA,WAAW,OAAO,WAAW,WAAW,SAAS,cAAc,CAAC,OAAO;QAC3E;QACA,MAAM,uBAAuB,CAAC;YAC1B,MAAM,EAAE,cAAc,EAAE,GAAG;YAC3B;;aAEC,GACD,IAAI,IAAI,CAAC,QAAQ,KAAK,gBAClB;YACJ,IAAI,CAAC,QAAQ,GAAG;YAChB;;;aAGC,GACD,IAAI,QAAQ,CAAC,kBAAkB,IAAI,CAAC,cAAc,EAAE;gBAChD;YACJ,OACK,IAAI,gBAAgB;gBACrB,IAAI,CAAC,cAAc,GAAG;YAC1B;YACA,IAAI,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;gBAC1B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,eAAe;YACtD;YACA;;;aAGC,GACD,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;YAC/D,MAAM,WAAW,iBAAiB,kBAAkB;YACpD,YAAY,SAAS;QACzB;QACA,OAAO,CAAA,GAAA,0LAAA,CAAA,sBAAmB,AAAD,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS;IAC3D;IACA,QAAQ;QACJ,IAAI,CAAC,aAAa;IACtB;IACA,SAAS;QACL,IAAI,OAAO,yBAAyB,aAChC;QACJ,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,IAAI;QACtC,MAAM,oBAAoB;YAAC;YAAU;YAAU;SAAO,CAAC,IAAI,CAAC,yBAAyB,OAAO;QAC5F,IAAI,mBAAmB;YACnB,IAAI,CAAC,aAAa;QACtB;IACJ;IACA,UAAU,CAAE;AAChB;AACA,SAAS,yBAAyB,EAAE,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,UAAU,eAAe,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACrF,OAAO,CAAC,OAAS,QAAQ,CAAC,KAAK,KAAK,YAAY,CAAC,KAAK;AAC1D"}},
    {"offset": {"line": 2262, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2327, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs"],"sourcesContent":["import { color } from '../../../value/types/color/index.mjs';\nimport { complex } from '../../../value/types/complex/index.mjs';\nimport { dimensionValueTypes } from './dimensions.mjs';\nimport { testValueType } from './test.mjs';\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\nexport { findValueType };\n"],"names":[],"mappings":";;;;;;;;;;;;AAKA;;CAEC,GACD,MAAM,aAAa;OAAI,4LAAA,CAAA,sBAAmB;IAAE,+KAAA,CAAA,QAAK;IAAE,iLAAA,CAAA,UAAO;CAAC;AAC3D;;CAEC,GACD,MAAM,gBAAgB,CAAC,IAAM,WAAW,IAAI,CAAC,CAAA,GAAA,sLAAA,CAAA,gBAAa,AAAD,EAAE"}},
    {"offset": {"line": 2350, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}